<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Einheit 8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Prof. Dr. Stephan Goerigk" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#EE0071"],"pen_size":4,"eraser_size":40,"palette":[]}) })</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




name: Title slide
class: middle, left
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
# Multivariate Verfahren
***
### Einheit 8: Multivariate (latente) Modellierung (2)
##### 12.12.2024 | Prof. Dr. Stephan Goerigk

---
class: top, left
### Multivariate (latente) Modellierung

.pull-left[

#### Strukturgleichungsmodelle in R - CFA Beispiel

&lt;small&gt;
* Das Modell (rechts) stellt die CFA für einen Kognitionstest dar (Holzinger &amp; Swineford, 1939).

*	Ein visueller Faktor, gemessen durch die 3 Variablen: `\(x_1\)`, `\(x_2\)` und `\(x_3\)`.

*	Ein textueller Faktor, gemessen durch die 3 Variablen: `\(x_4\)`, `\(x_5\)` und `\(x_6\)`.

*	Ein Geschwindigkeitsfaktor, gemessen durch die 3 Variablen: `\(x_7\)`, `\(x_8\)` und `\(x_9\)`.

***

Modell in `lavaan`:



.code90[

``` r
model &lt;- 'visual  =~ x1 + x2 + x3 
          textual =~ x4 + x5 + x6
          speed   =~ x7 + x8 + x9'

fit &lt;- cfa(model, data = HolzingerSwineford1939)
```
]
]

.pull-right[
.center[
&lt;img src="bilder/holzinger.png" width="300px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

&lt;small&gt; &lt;small&gt;

.pull-left[

#### Strukturgleichungsmodelle in R - CFA Beispiel

.center[
&lt;img src="bilder/Holzinger_withnumbers.png" width="340px" /&gt;
]

]

.pull-right[
.code80[

``` r
parameterEstimates(fit)
```
]
.center[
&lt;img src="bilder/holzinger2.png" width="300px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

&lt;small&gt; &lt;small&gt;

.pull-left[

#### Strukturgleichungsmodelle in R - CFA Beispiel

Die Ausgabe besteht aus drei Teilen. Die ersten neun Zeilen werden als Header bezeichnet. Der Header enthält die folgenden Informationen:

*	die verwendete lavaan-Version

*	ob die Optimierung normal beendet wurde oder nicht und wie viele Iterationen dafür benötigt wurden

*	den Schätzer, der verwendet wurde (hier: ML, für Maximum-Likelihood)

*	den Optimizer, der verwendet wurde, um die am besten passenden Parameterwerte für diesen Schätzer zu finden (hier: NLMINB)

*	die Anzahl der Modellparameter (hier: 21 )

*	die Anzahl der Beobachtungen, die effektiv in der Analyse verwendet wurden (hier: 301)

*	einen Abschnitt namens Model Test User Model, der einen Teststatistik-Wert, Freiheitsgrade und einen p-Wert für das vom Nutzer spezifizierte Modell bereitstellt.
]

.pull-right[
.code80[

``` r
fit
```

```
## lavaan 0.6-19 ended normally after 35 iterations
## 
##   Estimator                                         ML
##   Optimization method                           NLMINB
##   Number of model parameters                        21
## 
##   Number of observations                           301
## 
## Model Test User Model:
##                                                       
##   Test statistic                                85.306
##   Degrees of freedom                                24
##   P-value (Chi-square)                           0.000
```
]

]


---
class: top, left
### Multivariate (latente) Modellierung

&lt;small&gt; &lt;small&gt;

.pull-left[

#### Strukturgleichungsmodelle in R - CFA Beispiel

Anschließend werden alle freien (und festen) Parameter, die im Modell enthalten sind, tabellarisch dargestellt. Typischerweise werden zunächst die latenten Variablen angezeigt, gefolgt von Kovarianzen und (residualen) Varianzen.

*	Die erste Spalte `(Estimate)` enthält den (geschätzten oder festgelegten) Parameterwert für jeden Modellparameter.

*	Die zweite Spalte `(Std.err)` zeigt den Standardfehler für jeden geschätzten Parameter.

*	Die dritte Spalte `(Z-value)` enthält die Wald-Statistik (die einfach durch Division des Parameterwerts durch seinen Standardfehler berechnet wird).

*	Die letzte Spalte `(P(&gt;|z|))` enthält den p-Wert, um die Nullhypothese zu testen, dass der Parameterwert in der Population gleich null ist.
]

.pull-right[
.code80[

``` r
parameterEstimates(fit)
```
]
.center[
&lt;img src="bilder/holzinger2.png" width="300px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

&lt;small&gt; &lt;small&gt;

.pull-left[

#### Strukturgleichungsmodelle in R - CFA Beispiel

Abschnitt `Variances`: 

* Vor den Namen der beobachteten Variablen steht ein Punkt. 

  * Dies liegt daran, dass es sich um abhängige (oder endogene) Variablen handelt, die von den latenten Variablen vorhergesagt werden. 
  
  * Der in der Ausgabe angezeigte Wert für die Varianz ist daher eine Schätzung der Residualvarianz, also der übrig gebliebenen Varianz, die nicht durch die Prädiktor(en) erklärt wird.

* Dagegen steht kein Punkt vor den Namen der latenten Variablen, da sie in diesem Modell exogene Variablen sind (es zeigen keine einseitigen Pfeile auf sie). 

* Die angezeigten Werte für die Varianzen stellen hier die geschätzten Gesamtvarianzen der latenten Variablen dar.
]

.pull-right[
.code80[

``` r
parameterEstimates(fit)
```
]
.center[
&lt;img src="bilder/holzinger2.png" width="300px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

.center[
&lt;img src="bilder/Fit_indices.png" width="800px" /&gt;
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

&lt;small&gt;

`lavaan` liefert eine Vielzahl von Statistiken zur Modellpassung. Wir konzentrieren uns jedoch auf die 5 gängigsten:

*	Modell-Chi-Quadrat: Dies ist die Chi-Quadrat-Statistik, die aus der Maximum-Likelihood-Schätzung gewonnen wird (in `lavaan` als Test Statistic for the Model Test User Model bezeichnet).
	
*	CFI (Comparative Fit Index): Werte liegen zwischen 0 und 1. Werte &gt; 0.90 (konservativ: 0.95) deuten auf eine gute Modellanpassung hin.

*	TLI (Tucker-Lewis-Index): Auch dieser liegt zwischen 0 und 1. Werte &gt; 1 werden auf 1 gerundet. Werte über 0.90 weisen auf eine gute Modellanpassung hin. Wenn CFI und TLI beide unter 1 liegen, ist der CFI stets größer als der TLI.

* SRMR (Standardized-Root-Mean-Residual)

*	RMSEA (Root Mean Square Error of Approximation):

  *	In lavaan wird zusätzlich ein p-Wert für die „Close Fit“-Hypothese angegeben, der testet, ob RMSEA &lt; 0.05 ist.
	
	*	Wird das Modell abgelehnt, bedeutet dies, dass Ihr Modell keine „nahe“ Anpassung an die Daten zeigt.

`\(\rightarrow\)` Diese Fit-Maße gehören zu den wichtigsten Indikatoren für die Bewertung von Strukturgleichungsmodellen.

---
class: top, left
### Multivariate (latente) Modellierung

.pull-left[
#### Modellpassung und Fit indices

* In `lavaan` können Maße zur Modellpassung angezeigt werden

* Dafür setzen wir im `summary()` Befehl, `fit.measures = TRUE` ein.

* Die wichtigsten Indizes sind standardmäßig enthalten

* Für zusätzliche Maße kann `fitmeasures(fit)` genutzt werden
]

.pull-right[

``` r
summary(fit, fit.measures = TRUE)
```

.center[
&lt;img src="bilder/Holzinger_fitmeasures.png" width="280px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

&lt;small&gt;

** `\(\chi^2\)`-Test**

Das Modell-Chi-Quadrat wird definiert als entweder `\(N F_{ML}\)` oder `\((N - 1) F_{ML}\)` (je nach statistischem Paket)

$$
(N - 1) F_{ML}[S, \Sigma(\hat{\theta})] \sim \chi^2(df) \quad \text{mit } df = p - q
$$

* `\(p\)`: Anzahl bekannter Parameter  
* `\(q\)`: Anzahl zu schätzender Parameter  
* `\(N\)`: Anzahl der Versuchspersonen  
* `\(F_{ML}\)` ist die Fit-Funktion aus der Maximum-Likelihood-Methode ist, die zur Schätzung der Parameter im Modell verwendet wird.


Das Hypothesenpaar des `\(\chi^2\)`-Tests lautet_

* **H₀**: `\(\Sigma = S\)`  
* **H₁**: `\(\Sigma \neq S\)`  

* Unter **H₀** ist dieser Wert `\(\chi^2\)`-verteilt mit `\(df = p - q\)`.  

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

** `\(\chi^2\)`-Test**

* Je größer der `\(\chi^2\)`-Wert, desto größer ist der Unterschied zwischen der durch das Modell implizierten Kovarianzmatrix und der beobachteten Kovarianzmatrix. 

* Ergibt der Signifikanztest für diesen `\(\chi^2\)`-Wert ein `\(p &lt; 0.05\)`, wird die **H₀** abgelehnt.  

  * Das bedeutet, die modell-implizierte Kovarianzmatrix weicht signifikant von der empirischen Kovarianzmatrix ab.  

* Wird der Test **nicht signifikant**, spricht dies für einen guten Modellfit.  

  * Dadurch steigt die Wahrscheinlichkeit, dass das Modell abgelehnt wird.

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

** `\(\chi^2\)`-Test und Stichprobengröße/Power**

* Test ist sehr abhängig von der Stichprobengröße

* Große Stichproben:

  * In der Literatur ist gut dokumentiert, dass der `\(\chi^2\)`-Test in der Modellprüfung bei großen Stichproben überempfindlich reagiert. 

  * Für Modelle mit 75 bis 200 Fällen ein vernünftiges Maß für die Modellanpassung

  * Bei 400 oder mehr Fällen fällt er nahezu immer signifikant aus (Kenny, 2003).

* Kleine Stichproben: 

  * Auch große Abweichungen von einem perfekten Modell führen nicht zwangsläufig zur Ablehnung des Modells (underpowered).

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

&lt;small&gt;

** `\(\chi^2\)`-Test und Stichprobengröße/Power**

* Der `\(\chi^2\)`-Test ist empfindlich gegenüber großen Stichprobenumfängen, aber bedeutet das, dass wir uns auf kleine Stichproben beschränken sollten? 

  * Nein – größere Stichproben sind vorzuziehen. 

  * SEM sind für große Stichproben ausgelegt - Theorie basiert auf der Annahme, dass die Stichprobe so groß wie möglich ist.

Benötigte Stichprobengröße im SEM:

* Die `\(n:q\)` Regel- (Kline, 2016)

  * Stichprobengröße sollte von der Anzahl der Parameter in Ihrem Modell abhängen
  
  * empfohlenes Verhältnis von 20:1  
  
  * Das bedeutet, dass bei 10 Parametern die Stichprobengröße mindestens `\(n = 200\)` betragen sollte. 
  
  * Laut Kline ist eine Stichprobe von weniger als 100 Fällen nahezu immer unzureichend.

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Exakter vs. approximativer Modellfit**

Historisch war der `\(\chi^2\)`-Test die einzige Methode zur Prüfung der Modellanpassung. 

* In der Praxis wurde die `\(H_0\)` aufgrund der Empfindlichkeit des `\(\chi^2\)`-Tests häufig abgelehnt

* Daher wurden approximative Fit-Indizes entwickelt `\(\rightarrow\)` basieren nicht auf Verwerfung der `\(H_0\)`  

* Diese approximativen Fit-Indizes lassen sich weiter unterteilen in:

  * Absolute Fit-Indizes 
  
  * Relative Fit-Indizes (aka inkrementelle Fit-Indizes)

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Approximative Fit-Indizes**

* Relative Fit-Indizes (z.B. CFI, TLI)

  * Vergleichen Abweichung des genutzten Modells vom schlechtest passenden Modell (auch Baseline-Modell genannt) vs. Abweichung des saturierten Modells (auch bestes passendes Modell) vom Nullmodell. 
  
  * Nullmodell = alle Variablen unkorreliert (außer den Fehlertermen keine latenten Variablen und keine Zusammenhänge zwischen den Variablen)
  
  * Verhältnis sollte 1 betragen, wenn die Abweichung des genutzten Modells der Abweichung des saturierten Modells entspricht.
  
  * Je größer jedoch die Diskrepanz zwischen den Abweichungen ist, desto näher liegt das Verhältnis bei 0

* Absolute Fit-Indizes (z.B. RSMEA, SRMR)

  * Vergleichen genutztes Modell mit den beobachteten Daten.

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Relative Fit-Indizes - CFI (Comparative Fit Index)**

* CFI vergleicht genutztes Modells mit restriktiveren Nullmodell

$$
CFI = 1 - \frac{\chi^2_M - df_M}{\chi^2_N - df_N}
$$
  * `\(\chi^2_M:\)` Teststatistik des genutzten Modells
  * `\(\chi^2_N:\)` Teststatistik des Nullmodells

* Der Wertebereich liegt zwischen 0 und 1 (1 = optimaler Fit)

* Vorteil: weniger sensitiv gegenüber der Stichprobengröße `\((N)\)`

---
class: top, left
### Multivariate (latente) Modellierung

.pull-left[

#### Modellpassung und Fit indices

**Relative Fit-Indizes - CFI (Comparative Fit Index)**

* Berechnung des CFI im Beispiel:

$$
CFI = 1 - \frac{\chi^2_M - df_M}{\chi^2_N - df_N}
$$
$$
CFI = 1 - \frac{85.306 - 24}{918.852 - 36} = 0.931
$$

* Typische Empfehlung: 

  * CFI sollte &gt; 0.95 sein  (Hu &amp; Bentler, 1998)
]

.pull-right[
.center[
&lt;img src="bilder/Holzinger_fitmeasures.png" width="280px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Relative Fit-Indizes - TLI (Tucker Lewis Index)**

* TLI wird häufig zusammen mit dem CFI ausgegeben

* TLI nutzt relatives `\(\chi^2\)` (weniger empfindlich gegenüber der Stichprobengröße)

* Ein perfekt angepasstes Modell ergibt einen TLI, der genau 1 beträgt.

* Da der TLI und der CFI hoch korreliert sind, sollte nur einer der beiden berichtet werden.
$$
TLI = \frac{\frac{\chi^2_{N}}{df_N} - \frac{\chi^2_M}{df_M}}{\frac{\chi^2_N}{df_N} - 1}
$$


---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Absolute Fit-Indizes - RMSEA (Root-Mean-Square-Error of Approximation)**


$$
RMSEA = \sqrt{\frac{\chi^2 - df}{N \cdot df}}
$$
* RMSEA berücksichtigt sowohl Stichprobegröße als auch Modellkomplexität
  * Je komplexer ein Modell, desto weniger Freiheitsgrade
  * Nenner wird kleiner `\(\rightarrow\)` RMSEA wird größer

* Wertebereich zwischen 0 und 1 (optimaler Wert = 0)

* Nachteil: sensibel gegenüber fehlspezifizierten Ladungen und Pfaden.

---
class: top, left
### Multivariate (latente) Modellierung

.pull-left[

#### Modellpassung und Fit indices

**Absolute Fit-Indizes - RMSEA (Root-Mean-Square-Error of Approximation)**

* Berechnung des RMSEA im Beispiel:

$$
RMSEA = \sqrt{\frac{\chi^2 - df}{N \cdot df}}
$$
$$
RMSEA = \sqrt{\frac{85.306 - 24}{301 \cdot 24}} = 0.092
$$

* Typische Empfehlung (Hu &amp; Bentler, 1998):  
  * RMSEA `\(\leq 0.06\)` bei `\(N &gt; 250\)`.  
  * RMSEA `\(\leq 0.08\)` bei `\(N &lt; 250\)`. 
]

.pull-right[
.center[
&lt;img src="bilder/Holzinger_fitmeasures.png" width="280px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Absolute Fit-Indizes - SRMR (Standardized-Root-Mean-Residual)**

.pull-left[

`$$SRMR = \sqrt{\sum_{j} \sum_{k&lt;j}\frac{ r_{jk}^2}{e}}$$`

`$$r_{jk} = \frac{S_{jk}}{S_j \cdot S_k} - \frac{\hat{\sigma}_{jk}}{\hat{\sigma}_j \cdot \hat{\sigma}_k}$$`
`$$e = \frac{p \cdot (p+1)}{2}$$`

]

.pull-right[

&lt;small&gt;

* Wertebereich  zwischen 0 und 1 (optimale Wert = 0)

* SRMR gibt durchschnittliche Abweichung der beobachteten `\((S)\)` von der modellimplizierten Korrelationsmatrix `\((\Sigma)\)` an.  

* Formel:
  - `\(p\)`: Anzahl der manifesten Variablen  
  - `\(S\)`: modellimplizierte SDs/Kovarianz  
  - `\(\sigma\)`: aus Stichprobe geschätzte SDs/Kovarianz 
  
*  SRMR berücksichtigt weder Modellkomplexität noch die Stichprobengröße
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Zusammenfassung der Cutoff-Empfehlungen:**

* Cutoff-Werte für ML- Schätzalgorithmus (Hu &amp; Bentler, 1999)

  * RMSEA &lt; 0.06 bei N&gt;250; &lt; 0.08 bei N ≤ 250

  * SRMR &lt; 0.11

  * CFI &gt; 0.95

* Kritik an Cut-Off Werten

  * Cutoffs in der Praxis oft ni ht erreichtbar (Marsh, 2004)
  
  * Hu &amp; Bentler Empfehlungen in Daten mit sehr hohen Ladungen demonstriert


---
class: top, left
### Multivariate (latente) Modellierung

#### Modellpassung und Fit indices

**Voraussetzungen für Modelltests**

* Linearität

* Keine (Multi-) Kollinearität

  * mehrere Items korrelieren sehr hoch miteinander (Daumenregel: `\(r &gt; .85\)` problematisch)

* Ausreichende Stichprobengröße

* Angemessene Anzahl von Indikatoren pro latenter Variable

  * Daumenregel: mindestens vier Items pro latenter Variable
  
  * Mehr Items pro Faktor führen zu besseren Schätzungen (Marsh, Hau, Balla &amp; Grayson, 1998)

* Zutreffen angenommener Verteilungen

---
class: top, left
### Multivariate (latente) Modellierung

.pull-left[

#### Signifikanztest für einzelne Modellparameter

* Einzelne Modellparameter: z.B. Ladungen, Regressionen, Kovarianzen

* `lavaan` gibt Hypothesentest für Einzelparameter aus

  * `\(H_0:\)` Parameter = 0
  * `\(H_1:\)` Parameter `\(\neq\)` 0

* Teststatistik ist ein z-verteilter **critical ratio** (ähnlich Wald-Test bei Regression):

$$
C.R. = \frac{Estimate}{SE}
$$
* Wenn `P(&gt;|z|)` &lt; .05 wird `\(H_0\)` verworfen.
]

.pull-right[
.center[
&lt;img src="bilder/holzinger2.png" width="300px" /&gt;
]
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Fit Funktionen in `lavaan`

* `lavaan` unterstützt folgende Funktionen um ein Modell auf die Daten anzupassen:

  * `cfa()` `\(\rightarrow\)` Konfirmatorische Faktorenanalysen
  
  * `sem()` `\(\rightarrow\)` Strukturgleichungsmodelle
  
  * `growth()` `\(\rightarrow\)` latente Wachstuskurvenmodelle (Modelle mit Messwiederholungen)

* Benutzerfreundliche Funktionen, die viele Details automatisch übernehmen

* Um automatische Durchführung bestimmter Schritte zu vermeiden, kann Low-Level-Funktion lavaan() verwendet werdeb, die volle Kontrolle ermöglicht.

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R - SEM Beispiel



&lt;small&gt;

* Multivariate Zusammenhänge zwischen Schlafdauer, Aufmerksamkeit und Gedächtnisleistung.
* Aufmerksamkeit gleichzeitig endogen (wird erklärt durch Schlafdauer) und exogen (erklärt Gedächtnisleistung).

.center[
&lt;img src="bilder/lavaan_SEM.png" width="600px" /&gt;
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R - SEM Beispiel



&lt;small&gt;

* Multivariate Zusammenhänge zwischen Schlafdauer, Aufmerksamkeit und Gedächtnisleistung.
* Aufmerksamkeit gleichzeitig endogen (wird erklärt durch Schlafdauer) und exogen (erklärt Gedächtnisleistung).

.pull-left[

Aufstellen des Modells in `lavaan`:


``` r
model &lt;- '
  # measurement model
    sleep =~ x1 + x2 + x3
    attention =~ y1 + y2 + y3 + y4
    memory =~ y5 + y6 + y7 + y8
    
  # regressions
    attention ~ sleep
    memory ~ sleep + attention
'

fit &lt;- sem(model, data = df)
```
]

.pull-right[
In diesem Beispiel verwenden wir 2 Formeltypen: 

* Definitionen latenter Variablen (mit dem Operator =~) 
  
* Regressionsformeln (mit dem Operator ~).

]

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R - SEM Beispiel


``` r
summary(fit, standardized = TRUE)
```

.center[
&lt;img src="bilder/lavaan_SEM2.png" width="500px" /&gt;
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R - SEM Beispiel

**Zahlen im Outpuut standardisieren**

* Das Argument `standardized = TRUE` innerhalb der `summary()` Funktion erweitert den Output um standardisierte Parameterwerte. 

* Es werden zwei zusätzliche Spalten mit standardisierten Parameterwerten angezeigt:

	*	In der ersten Spalte (beschriftet mit `Std.lv`) werden nur die latenten Variablen standardisiert.
	
	*	In der zweiten Spalte (beschriftet mit `Std.all`) werden sowohl die latenten als auch die beobachteten Variablen standardisiert.

* Letztere wird oft als „vollständig standardisierte Lösung“ bezeichnet.

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R 

**Fixieren von Modellparametern**

* Standardmäßig fixiert lavaan die Faktorladung des ersten Indikators immer auf 1 

* Die anderen Parameter sind frei und ihre Werte werden vom Modell geschätzt.

* Es gibt jedoch inhaltliche Gründe Parameter in Modellen zu fixieren

* Zur Fixierung muss die entsprechende Variable in der Formel mit einem festen Wert multipliziert werden.

Folegende Formel fixiert z.B. alle Ladungen auf 1:


``` r
Faktor =~ x1 + 1*x2 + 1*x3 + 1*x4
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R 

&lt;small&gt;

**Fixieren von Modellparametern**

* Modellparameter können mit 0 fixiert werden, um voreingestellte Berechnungen zu ignorieren

* Beispiel: In einem CFA-Modell wird standardmäßig angenommen, dass alle exogenen latenten Variablen korreliert sind

* Wenn Sie jedoch die Korrelation zwischen einem Paar latenter Variablen auf Null festlegt werden soll, muss dies in der Modellsyntax berücksichtigt werden.

* Folgender Code würde annehmen, dass es zwischen den Faktoren visual/textual und speed keine Korrelation gibt (diese orthogonal sind), aber zwischen visual und textual schon:


``` r
model = '
  visual =~ x1 + x2 + x3
  textual =~ x4 + x5 + x6
  speed   =~ x7 + x8 + x9
  
  visual ~~ 0*speed
  textual ~~ 0*speed
'
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Strukturgleichungsmodelle in R 

**Fixieren von Modellparametern - Equality contraints**

* Equality contraints zwingen einzelne Paramter in einem Modell "gleich zu sein"

* Dies macht Sinn, wenn die Hypothese gleicher Ladungen oder gleicher Effekte zwischen Gruppen getestet werden soll

* Dies wird erreicht, indem für die jeweiligen Variablen ein identischer Multiplikator genutzt wird:

* Folgendes Modell nimmt z.B. identische Ladungen für `x2` und `x3` an

``` r
model = '
visual  =~ x1 + a*x2 + a*x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellvergleiche

* Modellvergleiche können für geschachtelte Modelle geprüft werden

* Geschachtelt = ein Modell konzeptuell im anderen enthalten (einfaches vs. komplexes Modell)

* Modelle, in denen Parameter fixiert werden sind "einfacher", da weniger freie Werte geschätzt werden müssen

.center[
&lt;img src="bilder/SEM_simplevscomplex.png" width="700px" /&gt;
]

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellvergleiche

* Geschachtelte Modelle können mittels **χ²-likelihood-ratio-test** verglichen werden.  

* Teststatistik des Modellvergleichs: `\(\Delta \chi^2 = \chi^2_{\text{einfach}} - \chi^2_{\text{komplex}}\)`
* Freiheitsgrade des Modellvergleichs: `\(\Delta df = df_{\text{einfach}} - df_{\text{komplex}}\)`

* Einfacheres Modell hat immer einen schlechteren Modellfit als ein komplexeres Modell. (Zu prüfen: Ist es signifikant schlechter?)

Interpretation:

* Signifikanter Modellvergleich: Das einfachere Modell ist signifikant schlechter ist als das komplexe Modell `\(\rightarrow\)` komplexes Modell wählen.  
  
* Nicht signifikanter Modellvergleich: Das einfachere Modell ist nicht signifikant schlechter ist als das komplexe Modell `\(\rightarrow\)` einfaches Modell wählen.  

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellvergleiche

* Beispiel: 2 Modelle werden angepasst

  * komplexes Modell: alle Parameter frei schätzen (außer die der ersten Indikatoren)
  
  * einfaches Modell: Ladungen für `x2` und `x3` sind fixiert.
  

``` r
komplex = '
visual  =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'

einfach = '
visual  =~ x1 + 1*x2 + 1*x3
textual =~ x4 + x5 + x6
speed   =~ x7 + x8 + x9
'
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellvergleiche


``` r
fiteinfach = cfa(einfach, data = HolzingerSwineford1939)
fitkomplex = cfa(komplex, data = HolzingerSwineford1939)

anova(fiteinfach, fitkomplex)
```

```
## 
## Chi-Squared Difference Test
## 
##            Df    AIC    BIC  Chisq Chisq diff   RMSEA Df diff Pr(&gt;Chisq)   
## fitkomplex 24 7517.5 7595.3 85.305                                         
## fiteinfach 26 7524.4 7594.9 96.253     10.948 0.12192       2   0.004195 **
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

* Einfaches Modell hat 2 freie Parameter mehr

* Modellvergleich ist signifikant `\(\rightarrow\)` komplexes Modell hat signifikant bessere Modellpassung

---
class: top, left
### Multivariate (latente) Modellierung

#### Modellvergleiche

* Sind Modelle nicht geschachtelt, können keine direkten Modellvergleiche gerechnet werden.

* Modellpassung muss anhand relativen Modellfits verglichen werden

* Hierfür wird oft das Akaike Information Criterion herangezogen (AIC)

* AIC-Interpretation: Das Modell mit dem kleineren AIC Wert ist zu bevorzugen.


``` r
anova(fiteinfach, fitkomplex) # Angenommen Modelle wären nicht geschachtelt
```

```
## 
## Chi-Squared Difference Test
## 
##            Df    AIC    BIC  Chisq Chisq diff   RMSEA Df diff Pr(&gt;Chisq)   
## fitkomplex 24 7517.5 7595.3 85.305                                         
## fiteinfach 26 7524.4 7594.9 96.253     10.948 0.12192       2   0.004195 **
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Kategoriale Daten

* Folgende Variablenarten werden als kategorial (nicht kontinuierlich) betrachtet:

  * Binäre Variablen
  * ordinale Variablen
  * nominale Variablen
  
* Wichtig: Es macht einen großen Unterschied, ob diese kategorialen Variablen im Modell exogen (unabhängig) oder endogen (abhängig) sind.

  * Exogene kategoriale Variablen sind relativ unproblematisch zu modellieren

  * Endogene kategoriale Variablen sind herausfordernder in der Modellierung

---
class: top, left
### Multivariate (latente) Modellierung

#### Kategoriale Daten

**Exogene kategoriale Variablen**

*	Binäre exogene Variable (z.B. Geschlecht)

  * Muss als Dummy-Variable (0/1) codiert werden, genauso wie in einem klassischen Regressionsmodell.
	
*	 Exogenen ordinale Variable 

  * Es kann ein Codierungsschema verwendet werden, das die Reihenfolge widerspiegelt (z. B. 1, 2, 3, …)
  
  * Variable kann wie jede andere numerische Variable behandelt werden.

*	nominale exogene Variable mit  `\(K &gt; 2\)`  Kategorien

  * muss durch ein Set von  `\(K-1\)`  Dummy-Variablen ersetzt werden

---
class: top, left
### Multivariate (latente) Modellierung

#### Kategoriale Daten

&lt;small&gt;

**Endogene kategoriale Variablen**

* `lavaan` kann derzeit mit binären und ordinalen (aber nicht nominalen) endogenen Variablen umgehen

* Dafür müssen kategoriale Variablen als `ordered` definiert werden

* Das ordered-Argument kann beim Fitting des Modells (cfa/sem/growth/lavaan) verwendet werden.

* Wenn Sie z.B. 3 binäre/ordinale Variablen haben (z. B. item1, item2, item3):


``` r
fit &lt;- cfa(model, data = df, ordered = c("item1","item2", "item3"))
```

* Wenn alle (endogenen) Variablen als kategorial behandelt werden sollen, kann pauschal `ordered = TRUE` verwendet werdeb.


``` r
fit &lt;- cfa(model, data = df, ordered = TRUE)
```

* Wenn das `ordered = TRUE` Argument verwendet wird, wechselt `lavaan` automatisch auf den `WLSMV` Schätzalgorithmus.

---
class: top, left
### Multivariate (latente) Modellierung

#### Fehlende Werte

* Wenn die Daten fehlende Werte enthalten, ist die Standardvorgehensweise die listwise deletion (Fallweises Löschen). 

* `lavaan` bietet die Möglichkeit der fallweisen Maximum-Likelihood-Schätzung (full information likelihood, FIML).

* Voraussetzung:  Werte fehlen MCAR (missing completely at random) oder MAR (missing at random) 

* FIML-Schätzung kann aktiviert werden, indem  das Argument `missing = "ML"` beim Aufruf der Anpassungsfunktion verwendet wird.


``` r
fit &lt;- cfa(model, data = df, missing = "ML")
```

---
class: top, left
### Multivariate (latente) Modellierung

#### Robuste Standardfehler und Bootstrapping

**Robuste Standardfehler**

* Robuste Standardfehler können explizit mit dem Argument `se = "robust"` angefordert werden. 

* Ebenso können robuste Teststatistiken explizit mit `test = "robust"` angefordert werden. 

* Sinnvoll z.B. bei Verteilungsverletzungen o.ä.

**Bootstrapping**

* Es kann entweder entweder `se = "bootstrap"` oder `test = "bootstrap"` beim Anpassen des Modells verwendet werden

* Dadurch werden Bootstrap-Standardfehler bzw. ein auf Bootstrap basierender p-Wert ausgegeben

* Sinnvoll bei nicht-normalverteilten Daten, kleinen Stichproben, komplexen Modellen oder unsicheren Modellannahmen

* Bootstrapping kann rechenintensiv sein, insbesondere bei großen Datensätzen

---
class: top, left
### Multivariate (latente) Modellierung

#### Vergleich implementierter Schätzmethoden

*	Maximum-Likelihood-Methode: Beantwortet die Frage, „Welche Parameter in der Population sind am wahrscheinlichsten, gegeben die beobachteten Daten?“
➙ liefert eine optimale Schätzung der Parameter der Population.

* GLS- und ULS-Methode: Minimieren die quadrierten Differenzen zwischen der beobachteten und der modellimplizierten Kovarianzmatrix.

*	ADF-Methode: Verwendet eine spezielle Kovarianzmatrix und basiert auf der Generalized Least Squares (GLS)-Schätzung.

  * benötigt große Stichproben (N &gt; 3000 empfohlen) und ist nur bei wenig komplexen Modellen gut
  
  * Vorteil: macht keine Verteilungsannahmen

*	WLSMV-Methode: Beruht auf einer gewichteten Schätzung der kleinsten quadratischen Abweichungen und berücksichtigt dabei Anpassungen für das arithmetische Mittel und die Varianz.

  * Vorteil: ermöglicht eine robuste Schätzung von Modellen mit dichotomen Variablen


---
class: top, left
### Take-aways

.full-width[.content-box-gray[
* Die Güte der Modellpassung eines SEMs kann mittels Fit-Indizes angegeben werden.

* Fit-Indizes werden in exakte bzw. approximative Maße unterteilt - approximative Maße weiterhin in relative und absolute Maße unterteilt.

* Die Güte eines Indizes wird anhand gängiger Cutoffs bewertet, welche in der Literatur jedoch auch Kritik unterliegen.

* Mit fehlenden Werten kann in SEMs mittels FIML-Schätzung umgegangen werden.

* Konkurrierende Modelle können mittels geschachtelten Modelltests oder durch den Abgleich relativer Indizes des Modellfits (z.B. AIC) verglichen werden

* `lavaan` kann im Falle von Voraussetzungsverletzungen robuste Standardfehler berechnen und Bootstrapping durchführen.
]
]


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "slideNumberFormat": "%current%",
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false,
  "ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
